이진 탐색 트리

정의 (공백이 아닌 이진 트리로서 다음을 만족한다)
    1. 모든 원소는 서로 다른 키를 갖는다
    2. 좌측 서브트리의 키들은 루트의 키보다 작다
    3. 우측 서브트리의 키들은 루트의 키보다 크다
    4. 좌측, 우측 서브트리도 이진 탐색 트리이다 >>> 컸다가 작아지는 그런 경우가 있으면 안된다

이진 탐색 트리에서의 탐색: 키 값이 k인 원소를 찾을 때
    (전제: 빈 트리가 아니다 + 키는 유일하기 때문에 '크거나 같은 경우' 따위는 없다)
    1. 루트 방문
    2. 루트의 키와 k 비교
    3. 루트의 키 > k일 경우 좌측 서브트리에서만 찾는다
    4. 루트의 키 < k일 경우 우측 서브트리에서만 찾는다

    계산복잡도: big-O(log n) (n=트리의 원소 수)



이진 탐색 트리에서의 삽입
     키 값이 k인 원소를 삽입한다고 할 때
     1. 공백 트리일 경우 그냥 새 노드로 삽입 후 종료
     2. 공백 트리가 아니라면 키 값을 검사하면서 들어갈 수 있는 위치 탐색
     3. 탐색 도중 이미 키 값이 있다는 것을 알게 되면 종료 >>> 정의 상 키는 유일하기 때문
     4. 적절한 위치를 찾아내면 삽입 후 종료

     계산복잡도: big-O(log n)



삭제
    CASE 1. 자식이 없는 노드일 경우 (==리프)
        - 삭제하고 끝
    CASE 2. 자식이 하나 있는 경우
        - 좌, 우 상관 없이 서브트리 루트(==자식)을 제거 대상의 자식으로 하면 된다
    CASE 3. 자식이 둘인 경우
        - 1. 좌측 서브트리의 가장 큰 노드를 가져와 보충하거나
        - 2. 우측 서브트리의 가장 작은 노드를 가져와 보충한다

    계산복잡도: big-O(log n)



결합
    1. 삼원 결합: (트리 A, 트리 B, 키 x)
        여기서 A 루트 키 < x < B 루트 키 라고 가정
        루트가 x, x의 좌측은 A,x의 우측은 B인 트리 생성
        높이는 max(A 높이, B 높이) + 1
        시간복잡도: big-O(1)

    2. 이원 결합: (트리 A, 트리 B)
        방법 1: A에서 가장 큰 키를 가져와 삼원 결합
        방법 2: B에서 가장 작은 키를 가져와 삼원 결합
        시간복잡도: big-O(h)



분할: 특정 키 값 x를 기준으로 분할
    결과: 하나는 키 값이 전부 x보다 커야 하고, 다른 하나는 x보다 작아야 한다
    CASE 1. x가 루트인 경우
        - 좌우로 분할하고 끝
    CASE 2. 그 외의 경우
        - x의 좌측 서브트리는 x보다 작은 키만 있는 서브트리로 옮긴다
        - x의 우측 서브트리는 x보다 큰 키만 있는 서브트리로 옮긴다



이진 탐색 트리의 높이
    - 평균 big-O(log n)
    - 최악의 경우가 big-O(log n)이면 이를 균형 탐색 트리라고 한다

    *** 균형 탐색 트리라고 절대 자식이 최대 둘이 아니다



힙

정의
    최대 힙: (부모 키 > 자식 키) && (완전 이진 트리)
    최소 힙: (부모 키 > 자식 키) && (완전 이진 트리)

    ***
    절대 "이진 탐색 트리"가 아니다.
    즉 반드시 좌측이 우측보다 작아야 하는 것이 아니라 둘 다 루트보다 작기만 하면 된다는 것이다 (최대 힙의 경우)

*** 아래 힙 동작들은 최대 힙을 상정하고 기술함

힙에서의 삽입
    주의
        - 완전 이진트리 형태를 유지해야 한다
        - 부모 노드가 누군지 잘 알 수 있어야 한다 >>> 순차 표현으로 하거나 back tracking 할 수 있어야 한다
    CASE 1. 삽입할 위치에 가능한 값 > 들어온 값
        - 넣고 끝
    CASE 2. 삽입할 위치에 가능한 값 < 들어온 값
        1. 부모 노드와 바꾼다
        2. 바꿨을 때 힙 정의를 만족하는지 검사한다. 즉 원래 부모의 부모와 비교한다
        3. 힙 조건을 만족할 때 까지 거슬러 올라간다

힙에서의 삭제
    1. 일단 지운다
    2. 빈 자리는 완전 이진 트리의 마지막 노드로 채운다
    3. 채워넣었을 때 힙 조건을 만족하는지 검사한다
    4. 만족하면 종료, 아니면 만족할 때까지 자식과 위치 변경