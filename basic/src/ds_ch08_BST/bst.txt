이진 탐색 트리

정의 (공백이 아닌 이진 트리로서 다음을 만족한다)
    1. 모든 원소는 서로 다른 키를 갖는다
    2. 좌측 서브트리의 키들은 루트의 키보다 작다
    3. 우측 서브트리의 키들은 루트의 키보다 크다
    4. 좌측, 우측 서브트리도 이진 탐색 트리이다 >>> 컸다가 작아지는 그런 경우가 있으면 안된다

이진 탐색 트리에서의 탐색: 키 값이 k인 원소를 찾을 때
    (전제: 빈 트리가 아니다 + 키는 유일하기 때문에 '크거나 같은 경우' 따위는 없다)
    1. 루트 방문
    2. 루트의 키와 k 비교
    3. 루트의 키 > k일 경우 좌측 서브트리에서만 찾는다
    4. 루트의 키 < k일 경우 우측 서브트리에서만 찾는다

    계산복잡도: big-O(log n) (n=트리의 원소 수 >>> log n=트리 높이)



이진 탐색 트리에서의 삽입
     키 값이 k인 원소를 삽입한다고 할 때
     1. 공백 트리일 경우 그냥 새 노드로 삽입 후 종료
     2. 공백 트리가 아니라면 키 값을 검사하면서 들어갈 수 있는 위치 탐색
     3. 탐색 도중 이미 키 값이 있다는 것을 알게 되면 종료 >>> 정의 상 키는 유일하기 때문
     4. 적절한 위치를 찾아내면 삽입 후 종료

     계산복잡도: 편향될 경우 big-O(n), 균형 탐색 트리일 경우 big-O(log n)



삭제
    CASE 1. 자식이 없는 노드일 경우 (==리프)
        - 삭제하고 끝
    CASE 2. 자식이 하나 있는 경우
        - 좌, 우 상관 없이 서브트리 루트(==자식)을 제거 대상의 자식으로 하면 된다
    CASE 3. 자식이 둘인 경우
        - 1. 좌측 서브트리의 가장 큰 노드를 가져와 보충하거나
        - 2. 우측 서브트리의 가장 작은 노드를 가져와 보충한다

    계산복잡도: big-O(log n)



결합
    1. 삼원 결합: (트리 A, 트리 B, 키 x)
        전제: A 루트 키 < x < B 루트 키
        루트가 x, x의 좌측은 A,x의 우측은 B인 트리 생성
        높이는 max(A 높이, B 높이) + 1
        시간복잡도: big-O(1)

    2. 이원 결합: (트리 A, 트리 B)
        전제: A의 모든 키 < B의 모든 키
        방법 1: A에서 가장 큰 키를 가져와 삼원 결합
        방법 2: B에서 가장 작은 키를 가져와 삼원 결합
        시간복잡도: big-O(h)

    *** 만약 1, 2 모두 전제가 없다면 다른 방법 필요 (이건 만들어보자)




분할: 특정 키 값 x를 기준으로 분할
    결과: 하나는 키 값이 전부 x보다 커야 하고, 다른 하나는 x보다 작아야 한다
    CASE 1. x가 루트인 경우
        - 좌우로 분할하고 끝
    CASE 2. 그 외의 경우
        - x의 좌측 서브트리는 x보다 작은 키만 있는 서브트리로 옮긴다
        - x의 우측 서브트리는 x보다 큰 키만 있는 서브트리로 옮긴다



이진 탐색 트리의 높이
    - 평균 big-O(log n), 진짜 최악은 편향된 경우로 big-O(n)
    - 최악의 경우가 big-O(log n)이면 이를 균형 탐색 트리라고 한다

    *** 균형 탐색 트리라고 자식이 둘만 있는게 아니다 (즉 이진탐색트리 ∈ 균형탐색트리)



힙

정의
    최대 힙: (부모 키 > 자식 키) && (완전 이진 트리)
    최소 힙: (부모 키 > 자식 키) && (완전 이진 트리)

    ***
    힙 == 이진 탐색 트리가 아니다.
    반드시 좌측이 우측보다 작아야 하는 것이 아니라 둘 다 루트보다 작기만 하면 된다는 것이다 (최대 힙의 경우)

*** 아래 힙 동작들은 최대 힙을 상정하고 기술함

힙에서의 삽입
    주의
        - 완전 이진트리 형태를 유지해야 한다
        - 부모 노드가 누군지 잘 알 수 있어야 한다 >>> 순차 표현으로 하거나 back tracking 할 수 있어야 한다
    CASE 1. 삽입할 위치에 가능한 값 > 들어온 값
        - 넣고 끝
    CASE 2. 삽입할 위치에 가능한 값 < 들어온 값
        1. 부모 노드와 바꾼다
        2. 바꿨을 때 힙 정의를 만족하는지 검사한다. 즉 원래 부모의 부모와 비교한다
        3. 힙 조건을 만족할 때 까지 거슬러 올라간다

힙에서의 삭제
    1. 루트 원소 삭제: 키가 가장 큰 원소
    2. 일단 맨 마지막 노드를 가져와 루트에 채운다
    3. 루트와 자식의 키를 비교한다. 루트가 크면 여기서 종료
    4. 자식이 크다면 두 자식 중 더 큰 키와 위치를 바꾼다
    5. 힙 조건을 만족할 때까지 3, 4를 반복한다



완전 이진 트리를 힙으로 변환 (순차 표현이라고 가정)
    1. for i=n/2, i >= 1, i--
    2. p=i
    3. for j=p*2, j <= n; j *= 2
    4. if j < n && H[j] < H[j+1], j=j+1 (자식 중 더 큰 쪽 선택)
    5. if H[p] >= H[j] exit
    6. else swap H[j] <> H[p]
    7. p = j
    8. 리프에 도달하거나 힙 조건을 만족할 때까지 3 ~ 7 반복

    ??? 연결 표현은 그냥 하나씩 삭제해서 다시 만드는 식으로 하는게 더 나을지도?



힙을 이용한 우선순위 큐
    힙을 이용해 우선순위 큐를 구현하면
        삽입: big-O(log n) 안에 이뤄진다
        삭제: big-O(1) 안에 이뤄진다 >>> 루트만 꺼내면 되기 때문



선택 트리
    들어가기 전
        런: 원소들이 정렬되어 있는 순서 순차 (~ 정렬된 리스트)

    k개의 런을 합치는 방법
        1. 각 런 맨 앞의 원소들 중 제일 작은 것만 골라가면서 합친다
        2. 선택 트리를 이용한다 (단, k >= 2)일 것

    승자 트리
        초기
            1. 리프엔 각 런의 첫 번째 원소가 들어간다
            2. 중간 노드는 두 자식 중 더 작은 쪽을 승자로 하여 들어간다
            3. 최후엔 루트에 k개 런에서 가장 작은 값이 들어간다
        중간
            CASE 1. 루트를 꺼낸다면?
                1. 루트와 값이 같은 곳을 쭉 따라간다
                2. 따라간 곳 맨 끝에서 런을 마주한다
                3. 마주한 런에서 원소를 하나 꺼낸다
                4. 이들을 이용해 다시 승자 트리를 구축한다

    패자 트리
        초기
            1. 리프엔 각 런의 첫 번째 원소가 들어간다
            2. 중간 노드엔 자식 중 패자(더 큰 쪽)을 나타낸다
            3. 중간 노드의 승자는 그 부모로 가 한 번 더 대전한다
            4. 중간 노드의 부모도 올라온 쪽 중 패자를 나타낸다
            5. 최후엔 루트는 결승 패자를 나타낸다.
            6. 최종 승자는 별도로 나타낸다.

        중간도 승자 트리와 유사하다




