큐?
    한쪽 끝에선 삽입하고 (rear에선 enqueue)
    다른쪽 끝에선 삭제하는 (front에선 dequeue)
    유한 순서 리스트 (들어올 수 있는 양이 한정된 리스트 (순차형/연결형 표현으로 구현 가능))

큐의 연산
    isEmpty: 큐가 비었는지 확인: 비었으면 true, 아니면 false 반환
    enqueue: 큐에서 rear가 가리키는 곳에 새 원소 삽입
    dequeue: 큐에서 front가 가리키는 원소를 떼어내 반환

큐의 순차 표현: 배열을 이용한 구현
    - 초기에 front, rear는 -1로 한다. >>> 공백 큐 표현
    - 빈 큐인지 알려면 front == rear인지 확인한다
    - enqueue 할 때
        rear != n-1인지 확인한다
        맞으면 rear를 1 증가시킨 후 삽입
        아니면 큐 확장 후 삽입
    - dequeue 할 때
        큐가 비었는지 확인한다
        빈 큐가 아니면 front를 1 증가시킨 후 큐에서 원소를 뽑아낸다

    한계: 공간을 알뜰하게 쓰려면 원소를 이동시켜야 한다
    해결: 원형으로 운용한다 >>> 순차 표현의 변형

큐의 원형 표현
    ~ 순차 표현
    front, rear 계산 시 %를 쓰는 방식으로 구현 >>> 큐 최대 크기를 넘어가면 % 연산으로 0부터 다시 시작
    교재에서의 형태
        초기에 front, rear를 0으로 설정한다
        enqueue 할 때 rear = (rear+1) % n 한 다음 삽입한다
        dequeue 할 때 front = (front+1) % n 한 다음 삭제한다
            >>> front는 삭제할 원소 앞을 가리키며, 항상 비어있다
            >>> 큐에 들어갈 수 있는 최대 원소 수는 (큐 길이-1)이다
        빈 큐인지 알기 위해선 (rear를 1 증가했을 때 rear==front)인지 확인한다

    원형 큐의 공간을 전부 쓰기 위해선 큐가 만원인지/비었는지 구분할 줄 알아야 한다
        원소 수를 따로 저장해두거나
        큐의 동작이 다음과 같을 때 원형 큐가 꽉 찼는지 확인하는 방법
            1.
                enq: rear 변경 후 삽입, deq: 삭제 후 front 변경 (OO)
                enq: 삽입 후 rear 변경, deq: 삭제 후 front 변경 (XO)
                    >>> ((rear+1) % n == front)인지 확인 후 진행
            2.
                enq: rear 변경 후 삽입, deq: front 변경 후 삭제 (OX)
                enq: 삽입 후 rear 변경, deq: front 변경 후 삭제 (XX)
                    >>> (rear % n == front 면서 rear != null)인지 확인 후 진행

큐의 연결 표현: 연결 리스트를 이용한 구현
    큐의 원소를 저장하기 위한 노드: (데이터, 링크)
    front: 리스트의 맨 앞 노드를 가리킨다
    rear: 리스트의 맨 뒤 노드를 가리킨다
    +++ count: 큐 안에 있는 원소 수
    공백 큐 확인: count==0



우선 순위 큐
    특정 값 key를 기준으로 했을 때 가장 큰 key 값을 먼저 제거하는 큐
    스택, 큐도 넓게 보면 우선순위 큐 >>> 들어온 시간이 key

    *** key가 만족해야 하는 성질
        1. 반사적 성질: ki <= ki
        2. 반대칭 성질: k1 <= k2이고 k2 <= k1이면 k1 == k2
        3. 이행적 성질: k1 <= k2, k2 <= k3 >>> k1 <= k3

우선 순위 큐 구현
    1. 정렬된 연결 리스트
        노드에 key를 추가한다
        삽입, 삭제 시 key 순이 내림차순이 되도록 유지하면서 작업을 수행한다
        특징: 삽입이 힘들고 삭제는 쉽다

    2. 무정렬 배열
        배열에 그냥 들어온 순서대로 넣는다
        삭제할 땐 각 원소의 우선순위를 일일이 비교해가면서 삭제 대상을 찾아낸다
        특징: 삽입은 간단하고 삭제가 힘들다

덱
    삽입, 삭제가 양 끝에서 이뤄질 수 있는 자료구조
    이중 연결 표현으로 구현하는 것이 보다 좋다