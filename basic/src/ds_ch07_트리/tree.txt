트리?
    '노드'와 '간선'으로 연결한 '계층형 자료 구조'

트리의 순환적 정의
    하나의 노드는 그 자체로 트리이며, 그 트리의 루트이다
    n이 노드이고 T1, 2, ...가 트리로서 노드 n1, 2, ...를 각각 루트로 가지고 있다고 할 때
    n을 부모로 n1, 2, ...를 연결하면 새로운 트리가 만들어진다
    이 트리에서 n은 루트고 T1, 2, ...은 n의 서브트리, n1, 2, ...은 n의 자식이다

용어
    차수: 노드가 갖고 있는 서브트리 수
    리프 노드: 차수가 0인 노드. aka 단말 노드, 터미널 노드
    자식: 노드의 서브트리 루트
    부모: 서브트리들의 루트
    형제: 한 부모 노드의 자식 노드들
    선조: 한 노드의 위에서 그 노드가 속한 트리의 루트까지의 노드
    트리의 차수: 최대 차수
    레벨: 루트의 경우 0, 그 외엔 부모의 레벨 + 1 >>> 루트의 ~대손
    노드의 높이: 루트에서 그 노드에 이르는 경로(==간선)의 수
    포레스트: n개의 서브트리를 가진 트리에서 루트 노드를 제거했을 때 서브트리들이 쪼개지면서 생기는 트리 집합

트리 표현 방법
    1. 리스트 내포 >>> A(B, C(D, E))
    2. 연결 표현



이진 트리
    모든 노드가 두개의 서브트리를 가지고 있는 트리
    서브트리가 공맥이면 리프 노드

이진 트리와 일반 트리의 차이
    1. 이진 트리는 공백 이진 트리가 있지만 일반 트리에는 공백 트리가 없다
    2. 이진 트리는 좌우를 구분한다. 즉 A(B, C)와 A(C, B)는 서로 다르다

용어
    포화 이진 트리: 높이가 h이고 노드 수가 2^(h+1)-1인 트리
    완전 이진 트리
        루트를 시작으로 레벨 별로 좌에서 우로 노드 위치에 번호를 매긴닥고 할 때
        노드 번호의 위치가 포화 이진 트리와 같을 때의 이진 트리

*** 생각해본 완전 이진 트리의 장점
    1. 편향된 트리에 비해 검색이 빠르다
    2. 순차 표현을 이용해 트리를 표현했을 경우 편향된 트리에 비해 기억 공간을 살뜰하게 쓸 수 있다

완전 이진 트리의 순차 표현
    1. 루트는 1부터 시작 >>> 배열 크기는 2^L + 1
    2. 노드 i의 부모: i/2의 몫 (단, i >= 2)
    3. 노드 i의 왼쪽 자식: i*2
    4. 노드 i의 오른쪽 자식: i*2 + 1 (3, 4 단, i*2, i*2+1 <= n)



이진 트리 순회
    *** 순회 시 항상 왼쪽 서브트리를 오른쪽 서브트리보다 먼저 방문한다고 가정
    1. 전위 순회: 루트 노드 방문 >>> 왼쪽 서브트리 방문 >>> 오른쪽 서브트리 방문
    2. 중위 순회: 왼쪽 서브트리 방문 >>> 루트 노드 방문 >>> 오른쪽 서브트리 방문
    3. 후위 순회: 왼쪽 서브트리 방문 >>> 오른쪽 서브트리 방문 >>> 루트 노드 방문
        >>> 구분 기준은 '루트의 방문 시기'
    4. 레벨 순서 순회: 루트 ENQ >>> 큐에 있는 노드 DEQ >>> 좌 / 우측 서브트리 ENQ



스레드 이진 트리











































