트리?
    '노드'와 '간선'으로 연결한 '계층형 자료 구조'

트리의 순환적 정의
    하나의 노드는 그 자체로 트리이며, 그 트리의 루트이다
    n이 노드이고 T1, 2, ...가 트리로서 노드 n1, 2, ...를 각각 루트로 가지고 있다고 할 때
    n을 부모로 n1, 2, ...를 연결하면 새로운 트리가 만들어진다
    이 트리에서 n은 루트고 T1, 2, ...은 n의 서브트리, n1, 2, ...은 n의 자식이다

용어
    차수: 노드가 갖고 있는 서브트리 수
    리프 노드: 차수가 0인 노드. aka 단말 노드, 터미널 노드
    자식: 노드의 서브트리 루트
    부모: 서브트리들의 루트
    형제: 한 부모 노드의 자식 노드들
    선조: 한 노드의 위에서 그 노드가 속한 트리의 루트까지의 노드
    트리의 차수: 최대 차수
    레벨: 루트의 경우 0, 그 외엔 부모의 레벨 + 1 >>> 루트의 ~대손
    노드의 높이: 루트에서 그 노드에 이르는 경로(==간선)의 수
    포레스트: n개의 서브트리를 가진 트리에서 루트 노드를 제거했을 때 서브트리들이 쪼개지면서 생기는 트리 집합

트리 표현 방법
    1. 리스트 내포 >>> A(B, C(D, E))
    2. 연결 표현



이진 트리
    모든 노드가 두개의 서브트리를 가지고 있는 트리
    서브트리가 공맥이면 리프 노드

이진 트리와 일반 트리의 차이
    1. 이진 트리는 공백 이진 트리가 있지만 일반 트리에는 공백 트리가 없다
    2. 이진 트리는 좌우를 구분한다. 즉 A(B, C)와 A(C, B)는 서로 다르다

용어
    포화 이진 트리: 높이가 h이고 노드 수가 2^(h+1)-1인 트리
    완전 이진 트리
        루트를 시작으로 레벨 별로 좌에서 우로 노드 위치에 번호를 매긴닥고 할 때
        노드 번호의 위치가 포화 이진 트리와 같을 때의 이진 트리

*** 생각해본 완전 이진 트리의 장점
    1. 편향된 트리에 비해 검색이 빠르다
    2. 순차 표현을 이용해 트리를 표현했을 경우 편향된 트리에 비해 기억 공간을 살뜰하게 쓸 수 있다

완전 이진 트리의 순차 표현
    1. 루트는 1부터 시작 >>> 배열 크기는 2^L + 1
    2. 노드 i의 부모: i/2의 몫 (단, i >= 2)
    3. 노드 i의 왼쪽 자식: i*2
    4. 노드 i의 오른쪽 자식: i*2 + 1 (3, 4 단, i*2, i*2+1 <= n)



이진 트리 순회
    *** 순회 시 항상 왼쪽 서브트리를 오른쪽 서브트리보다 먼저 방문한다고 가정
    1. 전위 순회: 루트 노드 방문 >>> 왼쪽 서브트리 방문 >>> 오른쪽 서브트리 방문
    2. 중위 순회: 왼쪽 서브트리 방문 >>> 루트 노드 방문 >>> 오른쪽 서브트리 방문
    3. 후위 순회: 왼쪽 서브트리 방문 >>> 오른쪽 서브트리 방문 >>> 루트 노드 방문
        >>> 구분 기준은 '루트의 방문 시기'
    4. 레벨 순서 순회: 루트 ENQ >>> 큐에 있는 노드 DEQ >>> 좌 / 우측 서브트리 ENQ



스레드 이진 트리
    이진 트리에서 노드의 링크 절반 가량이 남는 것을 활용한 이진 트리
    어떻게? >>> 중위 순회에 유용하도록 빈 left는 중위 선행자, right는 중위 후속자에 대한 포인터로 사용
    이를 위해 노드 양 끝에 불리언 필드 lt, rt를 추가해 자식이 있는지 표시
        if true >>> 선행자(left) / 후속자(right)를 가리킨다
        if false >>> 자식 노드를 가리킨다
    이 때 가장 왼쪽 노드는 left, 가장 오른쪽 노드는 right가 가리킬 대상이 없는데 이들은 헤더 노드를 추가해 가리키도록 한다

    *** 스레드 이진 트리의 헤더 노드
        구조는 스레드 이진 트리에 사용했던 노드와 똑같다
        헤더 노드의 left는 스레드 이진 트리의 루트를 가리키도록 한다



일반 트리를 이진 트리로 변환
    사용하는 노드 형태
        data: 노드 데이터
        child: 노드의 첫 자손
        siblings: 자신과 순회를 마친 형제 노드를 제외한 나머지 형제 노드들

    전위 순회
        >>> 루트 방문
        >>> 첫번째 서브트리 전위 순회 (즉, child 를 루트로 하는 서브트리 중위 순회)
        >>> 나머지 서브트리 전위 순회 (즉, siblings 를 루트로 하는 서브트리들을 전위 순회)
    중위 순회: 첫번째 서브트리 중위 순회 >>> 루트 방문 >>> 나머지 서브트리 중위 순회
    후위 순회: 첫번째 서브트리 후위 순회 >>> 나머지 서브트리 후위 순회 >>> 루트 방문

    +++ 레벨 순서 순회: 루트 방문 >>> siblings 루트 편입 >>> 서브트리가 있다면 레벨 순서 순회, 없다면 다음 siblings를 레벨 순서 순회

일반 트리를 이진 트리로 변환할 때의 특징
    원본에서 루트였던 노드는 siblings가 없다
    변환 전 트리를 전위 순회한 결과는 변환된 이진 트리를 전위 순회한 결과와 같다
    변환 전 트리를 후위 순회한 결과는 변환된 이진 트리를 중위 순회한 결과와 같다
    변환 전 트리를 중위 순회한 결과는 변환된 이진 트리 순회 방법들 중 일치하는 것이 없다



일반 포레스트 순회
    방법은 일반 트리 순회와 거의 같다.

일반 포레스트 변환 전후의 순회 결과
    전위 순회, 중위 순회: 변환된 이진 트리를 순회한 결과와 같다
    후위 순회: 일치하는 결과가 없다
    레벨 순서 순회: 변환 전 레벨 순서 순회 결과와 일치하지 않는다 >>> 변형 중 레벨이 바뀌기 때문





